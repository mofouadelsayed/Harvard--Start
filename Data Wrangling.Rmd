---
title: "Data Wrangling"
author: "MO"
date: "30/03/2021"
output: html_document
---
```{r include=FALSE}
library(tidyverse)
library(dslabs)
```

- Spreadsheet files have data stored in rows & columns. If that spreadsheet is opened with a normal text editor the "ROWS" will be separated by "Enter" & the columns will be separated by "," or ";" or " ". It may either also contain a header or not. NOTE: Excel sheets can't be viewed with a text editor.

- To know my current working directory in R `getwd()` & to change the working directory `setwd()`. NOTE: it's always better to provide a full path of the directory i want to change into because by default, if i don't do that, the system will look for files in my current working directory. Ex: `setwd("~/Desktop/HarvardX Data Science/6. Data Wrangling")`
```{r}
# For Example: to know the directory in which the "dslabs" package was installed & what files are in that directory i can do the following
path<- system.file("extdata", package = "dslabs")
path
list.files(path)
```

- Now lets say i want to copy one of the above files to my working directory. I will define the file name i want to copy, then i will define the full path it's located in then i'll copy all that into my working directory. Then i can double check if the file was actually copied
```{r}
filename<- "murders.csv"
fullpath<- file.path(path, filename)
fullpath
file.copy(fullpath, getwd())
file.exists(filename)
```

- Tidyverse package includes functions to read data from Excel sheets directly. They are as follows:
1. `read_excel`: auto detects the excel sheet format either "xls" or "xlsx"
2. `read_xls`: reads files with "xls" format
3. `read_xlsx`: reads files with "xlsx" format
*NOTE:* The sheet function in the above functions specify the sheet to read.

- I can use `read_lines("murders.csv", n_max=3) to read the first 3 lines in that file to know to double check if it has a header & if it's comma or semicolon separated.

- Since i'm trying to import or read a "csv" file, i should use the function as below then i can normally use the `head()` function to check the first 6 lines
```{r}
dat<- read_csv(filename)
```
**OR**
```{r}
dat<- read_csv(fullpath)
class(dat)
```
```{r}
head(dat)
```

- All the above read functions are available in base R as well, but they all use "." instead of "_" in the function name & when the data is imported as data frames as opposed to tibbles in the tidyverse functions. and the strings are converted to factors.
```{r}
dat2<- read.csv(filename)
class(dat2)
```

- To import files from the internet i have 2 options. I can either import or read the file directly from the "url" or i can download a copy on my computer.
```{r eval=FALSE, include=FALSE}
url <- "https://raw.githubusercontent.com/rafalab/dslabs/master/inst/extdata/murders.csv"
dat <- read_csv(url)                              # To read the file directly from the url
download.file(url, "murders.csv")                 # To download the file to my computer
```

- Plotting data as we used to do in the "Visualization" module worked so seamlessly because data was in "tidy" format, which means it was suitable for plotting because it was edited from it's raw format in a format that makes it easy to plot. For Example: every data point was in a different row, there was a header, etc.. below we can examine the raw data of the "gapminder" dataset.
```{r}
path <- system.file("extdata", package="dslabs")
filename <- file.path(path,  "fertility-two-countries-example.csv")
wide_data <- read_csv(filename)
select(wide_data, country, `1960`:`1967`)         # To check the first 9 columns
```

- Now we need to reshape the "Raw" or "wide" data into a "tidy" format so that we can work with it in R. there are several functions in the "tidyr" package which is a part of the "tidyverse" package already that can do that. below we will explore some functions of that package.

- First function we can use is the `gather()` function which will help us group all the year columns we have under one column & will add the relevant fertility data under those columns. This function takes 4 arguments `gather(1, 2, 3, 4)`. The third argument will be the columns i want to group under one column or title, The first argument will be that title or column name i want to group all other columns under & finally the second argument will be the data i want to include in that table. 
```{r}
new_tidy_data<- wide_data %>% gather(year, fertility, '1960' : '2015')
head(new_tidy_data)

# Since the ONLY column that was not gathered from the wide_data in the example above was the country,i can alternatively write the code like this. Both give the same result but that might help if there are more than 2 columns to gather.
new_tidy_data<- wide_data %>% gather(year, fertility, -country)
class(new_tidy_data$year)
head(new_tidy_data)
```

- The fourth argument is a "convert" argument to convert "characters" into "integers". By examining the class of the "year" column in the data gathered above it appears to be a "character" although in the formatted data it was "integer". This is because the gather function assumes the columns contain characters" not "integers" unless the fourth argument is specified. in this case
```{r}
new_tidy_data<- wide_data %>% gather(year, fertility, -country, convert = TRUE)
class(new_tidy_data$year)
head(new_tidy_data)
```

-Now that the data is "tidy", I can generate a plot.
```{r}
new_tidy_data %>% ggplot(aes(year, fertility, color = country)) + geom_point()
```

- If for any reason i want to do the opposite, which is convert "tidy" data into "wide" data i can use the `spread()` function. it takes 2 arguments. First argument is the column that contains the data i want to spread & the second argument is the data i want to use to populate the table.
```{r}
new_wide_data<- new_tidy_data %>% spread(year, fertility)
select(new_wide_data, country, '1960' : '1967')
```

- Now we can work on a "Raw" file data that needs a bit more work to be converted into "tidy" format. As seen below, the problem with this data is that it's "wide" and that the columns first row are the year & the variable type.
```{r}
path<- system.file("extdata", package = "dslabs")
filename<- file.path(path, "life-expectancy-and-fertility-two-countries-example.csv")
raw_dat<- read_csv(filename)
select(raw_dat,1:5)
```

- First step would be to gather the columns as we did above
```{r}
dat<- raw_dat %>% gather(key, value, -country)
head(dat)
```

- Second we need to separate the year & the variable types. To do this we can use the `separate()` function which takes 3 arguments. `separate(1,2,3)` First argument is the name of the column to be separated, Second argument is the names to be used for the new columns & Third argument is the character that separates the variables i want to separate.
```{r}
dat %>% separate(key, c("year", "variable_name"), "_")
```

- The problem with the code above is that it removed the "_" separating the "life_expectancy" variable. In that case i can use the `extra` argument in the `separate()` function so that we can remove the first "_" between the year & the variable type only & keep all other "_" used in the columns.
```{r}
dat %>% separate(key, c("year", "variable_name"), sep = "_", extra = "merge")
```

- This looks better but still i need to have separate columns for each variable. In this case i can use the `spread()` function i used before.
```{r}
dat %>% separate(key, c("year", "variable_name"), sep="_", extra = "merge") %>% spread(variable_name, value)
```

- Lets say we have the data in the format we need but we want to combine data in 2 separate tables. For Example, lets say we want to combine data from the "muders" dataset with data from the "US elections dataset". One of the problems we could encounter would be that some states could be missing from one of the tables. In the example below, this is not the case as both datasets have the same states. We will see how these tables are joined below & then we will create another scenario where some states will be missing and we will see what could be the possible solutions for that situiation.
```{r}
data(murders)
head(murders)
data("polls_us_election_2016")
head(results_us_election_2016)
identical(results_us_election_2016$state, murders$state)
```

```{r}
tab<- left_join(murders, results_us_election_2016, by="state")
head(tab)
```

- Now we will illustrate how rows might be missing from each table we want to join & we will see how we can fix this issue.We will take a few rows from each of the datasets above & we will explore what options do we have for combining.
```{r}
tab1<- slice(murders, 1:6) %>% select(state, population)
tab1
tab2<- slice(results_us_election_2016, c(1:3, 5, 7:8)) %>% select(state, electoral_votes)
tab2
```

- **Option 1** would be to use `left_join()` to add electoral votes to whatever states are in "tab1"
```{r}
left_join(tab1, tab2)       # OR tab1 %>% left_join(tab2)
```

- **Option 2** would be to use `right_join()` to add the states in "tab1" to the electoral votes in "tab2"
```{r}
tab1 %>% right_join(tab2)
```

- **Option 3** would be to use `inner_join()` to keep only the states that have information from both tables & join them
```{r}
inner_join(tab1, tab2)
```

- **Option 4** would be to use `full_join()` to keep both tables as they are including the NA's & join them.
```{r}
full_join(tab1, tab2)
```

- **Option 5** would be to use `semi_join()` to keep only the data in tab1 that has corresponding data in tab2 *WITHOUT JOINING THEM*
```{r}
semi_join(tab1, tab2)
```

- **Option 6** would be to use `anti_join()` to keep in formation in tab1 that has NO corresponding data in tab2 *WITHOUT JOINING THEM*
```{r}
anti_join(tab1, tab2)
```

- Another way to combine data together is `bind_cols()` or `bind_rows()`. This "bind" function doesn't match data in either data frame to the other, it just add the columns or rows from one data frame to the other without any kind of matching. We will get an error only of the data frames or datasets i'm trying to combine don't match in length.Those are functions of the dplyr package & they produce the output in a "tibble" form. There are equivilant functions for those in base R `cbind()` & `rbind()` but those produce data frames or matrices as output.
```{r}
bind_cols(a=1:3, b=3:5)
```
```{r}
# Using the same functions to bind data frames
tab1<- tab[, 1:3]
tab2<- tab[, 4:6]
tab3<- tab[, 7:9]
new_tab<- bind_cols(tab1, tab2, tab3)
head(new_tab)
```

```{r}
tab1<- tab[1:2,]
tab2<- tab[3:4,]
bind_rows(tab1, tab2)
```

- Checking if will update